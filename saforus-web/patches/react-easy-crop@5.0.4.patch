diff --git a/Cropper.d.ts b/Cropper.d.ts
index 77fe28604a88d95f0ecbf9c1ede73d25d6a5e6ee..8ebe5878e6ccbad29325fd0e2ba1c33525d36b7c 100644
--- a/Cropper.d.ts
+++ b/Cropper.d.ts
@@ -1,52 +1,60 @@
 import React from 'react';
 import { Area, MediaSize, Point, Size, VideoSrc } from './types';
 export type CropperProps = {
-    image?: string;
-    video?: string | VideoSrc[];
-    transform?: string;
-    crop: Point;
-    zoom: number;
-    rotation: number;
-    aspect: number;
-    minZoom: number;
-    maxZoom: number;
-    cropShape: 'rect' | 'round';
-    cropSize?: Size;
-    objectFit?: 'contain' | 'cover' | 'horizontal-cover' | 'vertical-cover';
-    showGrid?: boolean;
-    zoomSpeed: number;
-    zoomWithScroll?: boolean;
-    onCropChange: (location: Point) => void;
-    onZoomChange?: (zoom: number) => void;
-    onRotationChange?: (rotation: number) => void;
-    onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void;
-    onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void;
-    onCropSizeChange?: (cropSize: Size) => void;
-    onInteractionStart?: () => void;
-    onInteractionEnd?: () => void;
-    onMediaLoaded?: (mediaSize: MediaSize) => void;
-    style: {
-        containerStyle?: React.CSSProperties;
-        mediaStyle?: React.CSSProperties;
-        cropAreaStyle?: React.CSSProperties;
-    };
-    classes: {
-        containerClassName?: string;
-        mediaClassName?: string;
-        cropAreaClassName?: string;
-    };
-    restrictPosition: boolean;
-    mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>;
-    disableAutomaticStylesInjection?: boolean;
-    initialCroppedAreaPixels?: Area;
-    initialCroppedAreaPercentages?: Area;
-    onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean;
-    onWheelRequest?: (e: WheelEvent) => boolean;
-    setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void;
-    setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void;
-    setMediaSize?: (size: MediaSize) => void;
-    setCropSize?: (size: Size) => void;
-    nonce?: string;
+  image?: string;
+  video?: string | VideoSrc[];
+  transform?: string;
+  crop: Point;
+  zoom: number;
+  rotation: number;
+  aspect: number;
+  minZoom: number;
+  maxZoom: number;
+  cropShape: "rect" | "round";
+  cropSize?: Size;
+  objectFit?: "contain" | "cover" | "horizontal-cover" | "vertical-cover";
+  showGrid?: boolean;
+  zoomSpeed: number;
+  zoomWithScroll?: boolean;
+  onCropChange: (location: Point) => void;
+  onZoomChange?: (zoom: number) => void;
+  onRotationChange?: (rotation: number) => void;
+  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void;
+  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void;
+  onCropSizeChange?: (cropSize: Size) => void;
+  onInteractionStart?: () => void;
+  onInteractionEnd?: () => void;
+  onMediaLoaded?: (mediaSize: MediaSize) => void;
+  //Patch starts
+  resizable?: boolean;
+  minCropSize?: Size;
+  maxCropSize?: Size;
+  onCropResize?: (cropSize: Size) => void;
+  //Patch ends
+  style: {
+    containerStyle?: React.CSSProperties;
+    mediaStyle?: React.CSSProperties;
+    cropAreaStyle?: React.CSSProperties;
+  };
+  classes: {
+    containerClassName?: string;
+    mediaClassName?: string;
+    cropAreaClassName?: string;
+  };
+  restrictPosition: boolean;
+  mediaProps:
+    | React.ImgHTMLAttributes<HTMLElement>
+    | React.VideoHTMLAttributes<HTMLElement>;
+  disableAutomaticStylesInjection?: boolean;
+  initialCroppedAreaPixels?: Area;
+  initialCroppedAreaPercentages?: Area;
+  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean;
+  onWheelRequest?: (e: WheelEvent) => boolean;
+  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void;
+  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void;
+  setMediaSize?: (size: MediaSize) => void;
+  setCropSize?: (size: Size) => void;
+  nonce?: string;
 };
 type State = {
     cropSize: Size | null;
@@ -60,94 +68,103 @@ type GestureEvent = UIEvent & {
     clientY: number;
 };
 declare class Cropper extends React.Component<CropperProps, State> {
-    static defaultProps: {
-        zoom: number;
-        rotation: number;
-        aspect: number;
-        maxZoom: number;
-        minZoom: number;
-        cropShape: "rect";
-        objectFit: "contain";
-        showGrid: boolean;
-        style: {};
-        classes: {};
-        mediaProps: {};
-        zoomSpeed: number;
-        restrictPosition: boolean;
-        zoomWithScroll: boolean;
-    };
-    imageRef: React.RefObject<HTMLImageElement>;
-    videoRef: React.RefObject<HTMLVideoElement>;
-    containerPosition: Point;
-    containerRef: HTMLDivElement | null;
-    styleRef: HTMLStyleElement | null;
-    containerRect: DOMRect | null;
-    mediaSize: MediaSize;
-    dragStartPosition: Point;
-    dragStartCrop: Point;
-    gestureZoomStart: number;
-    gestureRotationStart: number;
-    isTouching: boolean;
-    lastPinchDistance: number;
-    lastPinchRotation: number;
-    rafDragTimeout: number | null;
-    rafPinchTimeout: number | null;
-    wheelTimer: number | null;
-    currentDoc: Document | null;
-    currentWindow: Window | null;
-    resizeObserver: ResizeObserver | null;
-    state: State;
-    componentDidMount(): void;
-    componentWillUnmount(): void;
-    componentDidUpdate(prevProps: CropperProps): void;
-    initResizeObserver: () => void;
-    preventZoomSafari: (e: Event) => void;
-    cleanEvents: () => void;
-    clearScrollEvent: () => void;
-    onMediaLoad: () => void;
-    setInitialCrop: (cropSize: Size) => void;
-    getAspect(): number;
-    getObjectFit(): "contain" | "horizontal-cover" | "vertical-cover" | undefined;
-    computeSizes: () => Size | undefined;
-    saveContainerPosition: () => void;
-    static getMousePoint: (e: MouseEvent | React.MouseEvent | GestureEvent) => {
-        x: number;
-        y: number;
-    };
-    static getTouchPoint: (touch: Touch | React.Touch) => {
-        x: number;
-        y: number;
-    };
-    onMouseDown: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
-    onMouseMove: (e: MouseEvent) => void;
-    onScroll: (e: Event) => void;
-    onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => void;
-    onTouchMove: (e: TouchEvent) => void;
-    onGestureStart: (e: GestureEvent) => void;
-    onGestureMove: (e: GestureEvent) => void;
-    onGestureEnd: (e: GestureEvent) => void;
-    onDragStart: ({ x, y }: Point) => void;
-    onDrag: ({ x, y }: Point) => void;
-    onDragStopped: () => void;
-    onPinchStart(e: React.TouchEvent<HTMLDivElement>): void;
-    onPinchMove(e: TouchEvent): void;
-    onWheel: (e: WheelEvent) => void;
-    getPointOnContainer: ({ x, y }: Point, containerTopLeft: Point) => Point;
-    getPointOnMedia: ({ x, y }: Point) => {
-        x: number;
-        y: number;
-    };
-    setNewZoom: (zoom: number, point: Point, { shouldUpdatePosition }?: {
-        shouldUpdatePosition?: boolean | undefined;
-    }) => void;
-    getCropData: () => {
-        croppedAreaPercentages: Area;
-        croppedAreaPixels: Area;
-    } | null;
-    emitCropData: () => void;
-    emitCropAreaChange: () => void;
-    recomputeCropPosition: () => void;
-    render(): JSX.Element;
+  static defaultProps: {
+    zoom: number;
+    rotation: number;
+    aspect: number;
+    maxZoom: number;
+    minZoom: number;
+    cropShape: "rect";
+    objectFit: "contain";
+    showGrid: boolean;
+    style: {};
+    classes: {};
+    mediaProps: {};
+    zoomSpeed: number;
+    restrictPosition: boolean;
+    zoomWithScroll: boolean;
+    resizable?: boolean;
+    minCropSize?: Size;
+    maxCropSize?: Size;
+  };
+  imageRef: React.RefObject<HTMLImageElement>;
+  videoRef: React.RefObject<HTMLVideoElement>;
+  containerPosition: Point;
+  containerRef: HTMLDivElement | null;
+  styleRef: HTMLStyleElement | null;
+  containerRect: DOMRect | null;
+  mediaSize: MediaSize;
+  dragStartPosition: Point;
+  dragStartCrop: Point;
+  gestureZoomStart: number;
+  gestureRotationStart: number;
+  isTouching: boolean;
+  lastPinchDistance: number;
+  lastPinchRotation: number;
+  rafDragTimeout: number | null;
+  rafPinchTimeout: number | null;
+  wheelTimer: number | null;
+  currentDoc: Document | null;
+  currentWindow: Window | null;
+  resizeObserver: ResizeObserver | null;
+  state: State;
+  componentDidMount(): void;
+  componentWillUnmount(): void;
+  componentDidUpdate(prevProps: CropperProps): void;
+  initResizeObserver: () => void;
+  preventZoomSafari: (e: Event) => void;
+  cleanEvents: () => void;
+  clearScrollEvent: () => void;
+  onMediaLoad: () => void;
+  setInitialCrop: (cropSize: Size) => void;
+  getAspect(): number;
+  getObjectFit(): "contain" | "horizontal-cover" | "vertical-cover" | undefined;
+  computeSizes: () => Size | undefined;
+  saveContainerPosition: () => void;
+  static getMousePoint: (e: MouseEvent | React.MouseEvent | GestureEvent) => {
+    x: number;
+    y: number;
+  };
+  static getTouchPoint: (touch: Touch | React.Touch) => {
+    x: number;
+    y: number;
+  };
+  onMouseDown: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
+  onMouseMove: (e: MouseEvent) => void;
+  onScroll: (e: Event) => void;
+  onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => void;
+  onTouchMove: (e: TouchEvent) => void;
+  onGestureStart: (e: GestureEvent) => void;
+  onGestureMove: (e: GestureEvent) => void;
+  onGestureEnd: (e: GestureEvent) => void;
+  onDragStart: ({ x, y }: Point) => void;
+  onDrag: ({ x, y }: Point) => void;
+  onDragStopped: () => void;
+  onPinchStart(e: React.TouchEvent<HTMLDivElement>): void;
+  onPinchMove(e: TouchEvent): void;
+  onWheel: (e: WheelEvent) => void;
+  getPointOnContainer: ({ x, y }: Point, containerTopLeft: Point) => Point;
+  getPointOnMedia: ({ x, y }: Point) => {
+    x: number;
+    y: number;
+  };
+  setNewZoom: (
+    zoom: number,
+    point: Point,
+    {
+      shouldUpdatePosition,
+    }?: {
+      shouldUpdatePosition?: boolean | undefined;
+    }
+  ) => void;
+  getCropData: () => {
+    croppedAreaPercentages: Area;
+    croppedAreaPixels: Area;
+  } | null;
+  emitCropData: () => void;
+  emitCropAreaChange: () => void;
+  recomputeCropPosition: () => void;
+  render(): JSX.Element;
 }
 export default Cropper;
 //# sourceMappingURL=Cropper.d.ts.map
\ No newline at end of file
diff --git a/index.module.js b/index.module.js
index 079311f95ab400ccc0cdecb59223baeaa991987c..874982b437e6b76108064d85095131075fb0028f 100644
--- a/index.module.js
+++ b/index.module.js
@@ -83,6 +83,7 @@ function computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, r
     width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),
     height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)
   };
+  
   // we compute the pixels size naively
   var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));
   var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));
@@ -202,19 +203,25 @@ function classNames() {
   }).join(' ').trim();
 }
 
-var css_248z = ".reactEasyCrop_Container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  user-select: none;\n  touch-action: none;\n  cursor: move;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.reactEasyCrop_Image,\n.reactEasyCrop_Video {\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\n}\n\n.reactEasyCrop_Contain {\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.reactEasyCrop_Cover_Horizontal {\n  width: 100%;\n  height: auto;\n}\n.reactEasyCrop_Cover_Vertical {\n  width: auto;\n  height: 100%;\n}\n\n.reactEasyCrop_CropArea {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  box-sizing: border-box;\n  box-shadow: 0 0 0 9999em;\n  color: rgba(0, 0, 0, 0.5);\n  overflow: hidden;\n}\n\n.reactEasyCrop_CropAreaRound {\n  border-radius: 50%;\n}\n\n.reactEasyCrop_CropAreaGrid::before {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 0;\n  bottom: 0;\n  left: 33.33%;\n  right: 33.33%;\n  border-top: 0;\n  border-bottom: 0;\n}\n\n.reactEasyCrop_CropAreaGrid::after {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 33.33%;\n  bottom: 33.33%;\n  left: 0;\n  right: 0;\n  border-left: 0;\n  border-right: 0;\n}\n";
+var css_248z =
+  ".reactEasyCrop_Container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  user-select: none;\n  touch-action: none;\n  cursor: move;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.reactEasyCrop_Image,\n.reactEasyCrop_Video {\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\n}\n\n.reactEasyCrop_Contain {\n  max-width: 100%;\n  max-height: 100%;\n  margin: auto;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n.reactEasyCrop_Cover_Horizontal {\n  width: 100%;\n  height: auto;\n}\n.reactEasyCrop_Cover_Vertical {\n  width: auto;\n  height: 100%;\n}\n\n.reactEasyCrop_CropArea {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  border: 2px solid #736cfb;\n  box-sizing: border-box;\n  box-shadow: 0 0 0 9999em;\n  color: rgba(0, 0, 0, 0.5);\n  overflow: hidden;\n}\n\n.reactEasyCrop_CropAreaRound {\n  border-radius: 50%;\n}\n\n.reactEasyCrop_CropAreaGrid::before {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 0;\n  bottom: 0;\n  left: 33.33%;\n  right: 33.33%;\n  border-top: 0;\n  border-bottom: 0;\n}\n\n.reactEasyCrop_CropAreaGrid::after {\n  content: ' ';\n  box-sizing: border-box;\n  position: absolute;\n  border: 1px solid rgba(255, 255, 255, 0.5);\n  top: 33.33%;\n  bottom: 33.33%;\n  left: 0;\n  right: 0;\n  border-left: 0;\n  border-right: 0;\n}\n";
 
 var MIN_ZOOM = 1;
-var MAX_ZOOM = 3;
+var MAX_ZOOM = 4;
 var Cropper = /** @class */function (_super) {
   __extends(Cropper, _super);
   function Cropper() {
-    var _this = _super !== null && _super.apply(this, arguments) || this;
+    var _this = (_super !== null && _super.apply(this, arguments)) || this;
     _this.imageRef = React.createRef();
     _this.videoRef = React.createRef();
+    // Patching starts
+    _this.state = {
+      cropSize: { width: 100, height: 100 },
+    };
+    // Patching ends
     _this.containerPosition = {
       x: 0,
-      y: 0
+      y: 0,
     };
     _this.containerRef = null;
     _this.styleRef = null;
@@ -223,15 +230,15 @@ var Cropper = /** @class */function (_super) {
       width: 0,
       height: 0,
       naturalWidth: 0,
-      naturalHeight: 0
+      naturalHeight: 0,
     };
     _this.dragStartPosition = {
       x: 0,
-      y: 0
+      y: 0,
     };
     _this.dragStartCrop = {
       x: 0,
-      y: 0
+      y: 0,
     };
     _this.gestureZoomStart = 0;
     _this.gestureRotationStart = 0;
@@ -241,16 +248,16 @@ var Cropper = /** @class */function (_super) {
     _this.rafDragTimeout = null;
     _this.rafPinchTimeout = null;
     _this.wheelTimer = null;
-    _this.currentDoc = typeof document !== 'undefined' ? document : null;
-    _this.currentWindow = typeof window !== 'undefined' ? window : null;
+    _this.currentDoc = typeof document !== "undefined" ? document : null;
+    _this.currentWindow = typeof window !== "undefined" ? window : null;
     _this.resizeObserver = null;
     _this.state = {
       cropSize: null,
       hasWheelJustStarted: false,
-      mediaObjectFit: undefined
+      mediaObjectFit: undefined,
     };
     _this.initResizeObserver = function () {
-      if (typeof window.ResizeObserver === 'undefined' || !_this.containerRef) {
+      if (typeof window.ResizeObserver === "undefined" || !_this.containerRef) {
         return;
       }
       var isFirstResize = true;
@@ -269,16 +276,17 @@ var Cropper = /** @class */function (_super) {
     };
     _this.cleanEvents = function () {
       if (!_this.currentDoc) return;
-      _this.currentDoc.removeEventListener('mousemove', _this.onMouseMove);
-      _this.currentDoc.removeEventListener('mouseup', _this.onDragStopped);
-      _this.currentDoc.removeEventListener('touchmove', _this.onTouchMove);
-      _this.currentDoc.removeEventListener('touchend', _this.onDragStopped);
-      _this.currentDoc.removeEventListener('gesturemove', _this.onGestureMove);
-      _this.currentDoc.removeEventListener('gestureend', _this.onGestureEnd);
-      _this.currentDoc.removeEventListener('scroll', _this.onScroll);
+      _this.currentDoc.removeEventListener("mousemove", _this.onMouseMove);
+      _this.currentDoc.removeEventListener("mouseup", _this.onDragStopped);
+      _this.currentDoc.removeEventListener("touchmove", _this.onTouchMove);
+      _this.currentDoc.removeEventListener("touchend", _this.onDragStopped);
+      _this.currentDoc.removeEventListener("gesturemove", _this.onGestureMove);
+      _this.currentDoc.removeEventListener("gestureend", _this.onGestureEnd);
+      _this.currentDoc.removeEventListener("scroll", _this.onScroll);
     };
     _this.clearScrollEvent = function () {
-      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);
+      if (_this.containerRef)
+        _this.containerRef.removeEventListener("wheel", _this.onWheel);
       if (_this.wheelTimer) {
         clearTimeout(_this.wheelTimer);
       }
@@ -295,13 +303,27 @@ var Cropper = /** @class */function (_super) {
     };
     _this.setInitialCrop = function (cropSize) {
       if (_this.props.initialCroppedAreaPercentages) {
-        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
+        var _a = getInitialCropFromCroppedAreaPercentages(
+            _this.props.initialCroppedAreaPercentages,
+            _this.mediaSize,
+            _this.props.rotation,
+            cropSize,
+            _this.props.minZoom,
+            _this.props.maxZoom
+          ),
           crop = _a.crop,
           zoom = _a.zoom;
         _this.props.onCropChange(crop);
         _this.props.onZoomChange && _this.props.onZoomChange(zoom);
       } else if (_this.props.initialCroppedAreaPixels) {
-        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),
+        var _b = getInitialCropFromCroppedAreaPixels(
+            _this.props.initialCroppedAreaPixels,
+            _this.mediaSize,
+            _this.props.rotation,
+            cropSize,
+            _this.props.minZoom,
+            _this.props.maxZoom
+          ),
           crop = _b.crop,
           zoom = _b.zoom;
         _this.props.onCropChange(crop);
@@ -314,10 +336,27 @@ var Cropper = /** @class */function (_super) {
       if (mediaRef && _this.containerRef) {
         _this.containerRect = _this.containerRef.getBoundingClientRect();
         _this.saveContainerPosition();
-        var containerAspect = _this.containerRect.width / _this.containerRect.height;
-        var naturalWidth = ((_a = _this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
-        var naturalHeight = ((_c = _this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
-        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;
+        var containerAspect =
+          _this.containerRect.width / _this.containerRect.height;
+        var naturalWidth =
+          ((_a = _this.imageRef.current) === null || _a === void 0
+            ? void 0
+            : _a.naturalWidth) ||
+          ((_b = _this.videoRef.current) === null || _b === void 0
+            ? void 0
+            : _b.videoWidth) ||
+          0;
+        var naturalHeight =
+          ((_c = _this.imageRef.current) === null || _c === void 0
+            ? void 0
+            : _c.naturalHeight) ||
+          ((_d = _this.videoRef.current) === null || _d === void 0
+            ? void 0
+            : _d.videoHeight) ||
+          0;
+        var isMediaScaledDown =
+          mediaRef.offsetWidth < naturalWidth ||
+          mediaRef.offsetHeight < naturalHeight;
         var mediaAspect = naturalWidth / naturalHeight;
         // We do not rely on the offsetWidth/offsetHeight if the media is scaled down
         // as the values they report are rounded. That will result in precision losses
@@ -329,49 +368,72 @@ var Cropper = /** @class */function (_super) {
         if (isMediaScaledDown) {
           switch (_this.state.mediaObjectFit) {
             default:
-            case 'contain':
-              renderedMediaSize = containerAspect > mediaAspect ? {
-                width: _this.containerRect.height * mediaAspect,
-                height: _this.containerRect.height
-              } : {
-                width: _this.containerRect.width,
-                height: _this.containerRect.width / mediaAspect
-              };
+            case "contain":
+              renderedMediaSize =
+                containerAspect > mediaAspect
+                  ? {
+                      width: _this.containerRect.height * mediaAspect,
+                      height: _this.containerRect.height,
+                    }
+                  : {
+                      width: _this.containerRect.width,
+                      height: _this.containerRect.width / mediaAspect,
+                    };
               break;
-            case 'horizontal-cover':
+            case "horizontal-cover":
               renderedMediaSize = {
                 width: _this.containerRect.width,
-                height: _this.containerRect.width / mediaAspect
+                height: _this.containerRect.width / mediaAspect,
               };
               break;
-            case 'vertical-cover':
+            case "vertical-cover":
               renderedMediaSize = {
                 width: _this.containerRect.height * mediaAspect,
-                height: _this.containerRect.height
+                height: _this.containerRect.height,
               };
               break;
           }
         } else {
           renderedMediaSize = {
             width: mediaRef.offsetWidth,
-            height: mediaRef.offsetHeight
+            height: mediaRef.offsetHeight,
           };
         }
         _this.mediaSize = __assign(__assign({}, renderedMediaSize), {
           naturalWidth: naturalWidth,
-          naturalHeight: naturalHeight
+          naturalHeight: naturalHeight,
         });
         // set media size in the parent
         if (_this.props.setMediaSize) {
           _this.props.setMediaSize(_this.mediaSize);
         }
-        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);
-        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {
-          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);
+        var cropSize = _this.props.cropSize
+          ? _this.props.cropSize
+          : getCropSize(
+              _this.mediaSize.width,
+              _this.mediaSize.height,
+              _this.containerRect.width,
+              _this.containerRect.height,
+              _this.props.aspect,
+              _this.props.rotation
+            );
+        if (
+          ((_e = _this.state.cropSize) === null || _e === void 0
+            ? void 0
+            : _e.height) !== cropSize.height ||
+          ((_f = _this.state.cropSize) === null || _f === void 0
+            ? void 0
+            : _f.width) !== cropSize.width
+        ) {
+          _this.props.onCropSizeChange &&
+            _this.props.onCropSizeChange(cropSize);
         }
-        _this.setState({
-          cropSize: cropSize
-        }, _this.recomputeCropPosition);
+        _this.setState(
+          {
+            cropSize: cropSize,
+          },
+          _this.recomputeCropPosition
+        );
         // pass crop size to parent
         if (_this.props.setCropSize) {
           _this.props.setCropSize(cropSize);
@@ -384,15 +446,15 @@ var Cropper = /** @class */function (_super) {
         var bounds = _this.containerRef.getBoundingClientRect();
         _this.containerPosition = {
           x: bounds.left,
-          y: bounds.top
+          y: bounds.top,
         };
       }
     };
     _this.onMouseDown = function (e) {
       if (!_this.currentDoc) return;
       e.preventDefault();
-      _this.currentDoc.addEventListener('mousemove', _this.onMouseMove);
-      _this.currentDoc.addEventListener('mouseup', _this.onDragStopped);
+      _this.currentDoc.addEventListener("mousemove", _this.onMouseMove);
+      _this.currentDoc.addEventListener("mouseup", _this.onDragStopped);
       _this.saveContainerPosition();
       _this.onDragStart(Cropper.getMousePoint(e));
     };
@@ -410,10 +472,10 @@ var Cropper = /** @class */function (_super) {
       if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {
         return;
       }
-      _this.currentDoc.addEventListener('touchmove', _this.onTouchMove, {
-        passive: false
+      _this.currentDoc.addEventListener("touchmove", _this.onTouchMove, {
+        passive: false,
       }); // iOS 11 now defaults to passive: true
-      _this.currentDoc.addEventListener('touchend', _this.onDragStopped);
+      _this.currentDoc.addEventListener("touchend", _this.onDragStopped);
       _this.saveContainerPosition();
       if (e.touches.length === 2) {
         _this.onPinchStart(e);
@@ -433,8 +495,8 @@ var Cropper = /** @class */function (_super) {
     _this.onGestureStart = function (e) {
       if (!_this.currentDoc) return;
       e.preventDefault();
-      _this.currentDoc.addEventListener('gesturechange', _this.onGestureMove);
-      _this.currentDoc.addEventListener('gestureend', _this.onGestureEnd);
+      _this.currentDoc.addEventListener("gesturechange", _this.onGestureMove);
+      _this.currentDoc.addEventListener("gestureend", _this.onGestureEnd);
       _this.gestureZoomStart = _this.props.zoom;
       _this.gestureRotationStart = _this.props.rotation;
     };
@@ -447,7 +509,7 @@ var Cropper = /** @class */function (_super) {
       var point = Cropper.getMousePoint(e);
       var newZoom = _this.gestureZoomStart - 1 + e.scale;
       _this.setNewZoom(newZoom, point, {
-        shouldUpdatePosition: true
+        shouldUpdatePosition: true,
       });
       if (_this.props.onRotationChange) {
         var newRotation = _this.gestureRotationStart + e.rotation;
@@ -463,35 +525,50 @@ var Cropper = /** @class */function (_super) {
         y = _a.y;
       _this.dragStartPosition = {
         x: x,
-        y: y
+        y: y,
       };
       _this.dragStartCrop = __assign({}, _this.props.crop);
-      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);
+      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0
+        ? void 0
+        : _c.call(_b);
     };
     _this.onDrag = function (_a) {
       var x = _a.x,
         y = _a.y;
       if (!_this.currentWindow) return;
-      if (_this.rafDragTimeout) _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);
-      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(function () {
-        if (!_this.state.cropSize) return;
-        if (x === undefined || y === undefined) return;
-        var offsetX = x - _this.dragStartPosition.x;
-        var offsetY = y - _this.dragStartPosition.y;
-        var requestedPosition = {
-          x: _this.dragStartCrop.x + offsetX,
-          y: _this.dragStartCrop.y + offsetY
-        };
-        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;
-        _this.props.onCropChange(newPosition);
-      });
+      if (_this.rafDragTimeout)
+        _this.currentWindow.cancelAnimationFrame(_this.rafDragTimeout);
+      _this.rafDragTimeout = _this.currentWindow.requestAnimationFrame(
+        function () {
+          if (!_this.state.cropSize) return;
+          if (x === undefined || y === undefined) return;
+          var offsetX = x - _this.dragStartPosition.x;
+          var offsetY = y - _this.dragStartPosition.y;
+          var requestedPosition = {
+            x: _this.dragStartCrop.x + offsetX,
+            y: _this.dragStartCrop.y + offsetY,
+          };
+          var newPosition = _this.props.restrictPosition
+            ? restrictPosition(
+                requestedPosition,
+                _this.mediaSize,
+                _this.state.cropSize,
+                _this.props.zoom,
+                _this.props.rotation
+              )
+            : requestedPosition;
+          _this.props.onCropChange(newPosition);
+        }
+      );
     };
     _this.onDragStopped = function () {
       var _a, _b;
       _this.isTouching = false;
       _this.cleanEvents();
       _this.emitCropData();
-      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
+      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0
+        ? void 0
+        : _b.call(_a);
     };
     _this.onWheel = function (e) {
       if (!_this.currentWindow) return;
@@ -501,39 +578,51 @@ var Cropper = /** @class */function (_super) {
       e.preventDefault();
       var point = Cropper.getMousePoint(e);
       var pixelY = normalizeWheel(e).pixelY;
-      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;
+      var newZoom = _this.props.zoom - (pixelY * _this.props.zoomSpeed) / 200;
       _this.setNewZoom(newZoom, point, {
-        shouldUpdatePosition: true
+        shouldUpdatePosition: true,
       });
       if (!_this.state.hasWheelJustStarted) {
-        _this.setState({
-          hasWheelJustStarted: true
-        }, function () {
-          var _a, _b;
-          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);
-        });
+        _this.setState(
+          {
+            hasWheelJustStarted: true,
+          },
+          function () {
+            var _a, _b;
+            return (_b = (_a = _this.props).onInteractionStart) === null ||
+              _b === void 0
+              ? void 0
+              : _b.call(_a);
+          }
+        );
       }
       if (_this.wheelTimer) {
         clearTimeout(_this.wheelTimer);
       }
       _this.wheelTimer = _this.currentWindow.setTimeout(function () {
-        return _this.setState({
-          hasWheelJustStarted: false
-        }, function () {
-          var _a, _b;
-          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);
-        });
+        return _this.setState(
+          {
+            hasWheelJustStarted: false,
+          },
+          function () {
+            var _a, _b;
+            return (_b = (_a = _this.props).onInteractionEnd) === null ||
+              _b === void 0
+              ? void 0
+              : _b.call(_a);
+          }
+        );
       }, 250);
     };
     _this.getPointOnContainer = function (_a, containerTopLeft) {
       var x = _a.x,
         y = _a.y;
       if (!_this.containerRect) {
-        throw new Error('The Cropper is not mounted');
+        throw new Error("The Cropper is not mounted");
       }
       return {
         x: _this.containerRect.width / 2 - (x - containerTopLeft.x),
-        y: _this.containerRect.height / 2 - (y - containerTopLeft.y)
+        y: _this.containerRect.height / 2 - (y - containerTopLeft.y),
       };
     };
     _this.getPointOnMedia = function (_a) {
@@ -544,7 +633,7 @@ var Cropper = /** @class */function (_super) {
         zoom = _b.zoom;
       return {
         x: (x + crop.x) / zoom,
-        y: (y + crop.y) / zoom
+        y: (y + crop.y) / zoom,
       };
     };
     _this.setNewZoom = function (zoom, point, _a) {
@@ -554,13 +643,24 @@ var Cropper = /** @class */function (_super) {
       if (!_this.state.cropSize || !_this.props.onZoomChange) return;
       var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);
       if (shouldUpdatePosition) {
-        var zoomPoint = _this.getPointOnContainer(point, _this.containerPosition);
+        var zoomPoint = _this.getPointOnContainer(
+          point,
+          _this.containerPosition
+        );
         var zoomTarget = _this.getPointOnMedia(zoomPoint);
         var requestedPosition = {
           x: zoomTarget.x * newZoom - zoomPoint.x,
-          y: zoomTarget.y * newZoom - zoomPoint.y
+          y: zoomTarget.y * newZoom - zoomPoint.y,
         };
-        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;
+        var newPosition = _this.props.restrictPosition
+          ? restrictPosition(
+              requestedPosition,
+              _this.mediaSize,
+              _this.state.cropSize,
+              newZoom,
+              _this.props.rotation
+            )
+          : requestedPosition;
         _this.props.onCropChange(newPosition);
       }
       _this.props.onZoomChange(newZoom);
@@ -570,8 +670,24 @@ var Cropper = /** @class */function (_super) {
         return null;
       }
       // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)
-      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
-      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);
+      var restrictedPosition = _this.props.restrictPosition
+        ? restrictPosition(
+            _this.props.crop,
+            _this.mediaSize,
+            _this.state.cropSize,
+            _this.props.zoom,
+            _this.props.rotation
+          )
+        : _this.props.crop;
+      return computeCroppedArea(
+        restrictedPosition,
+        _this.mediaSize,
+        _this.state.cropSize,
+        _this.getAspect(),
+        _this.props.zoom,
+        _this.props.rotation,
+        _this.props.restrictPosition
+      );
     };
     _this.emitCropData = function () {
       var cropData = _this.getCropData();
@@ -596,12 +712,56 @@ var Cropper = /** @class */function (_super) {
     };
     _this.recomputeCropPosition = function () {
       if (!_this.state.cropSize) return;
-      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;
+      var newPosition = _this.props.restrictPosition
+        ? restrictPosition(
+            _this.props.crop,
+            _this.mediaSize,
+            _this.state.cropSize,
+            _this.props.zoom,
+            _this.props.rotation
+          )
+        : _this.props.crop;
       _this.props.onCropChange(newPosition);
       _this.emitCropData();
     };
     return _this;
   }
+  //Patch starts
+  // Add a mouse move event handler
+  Cropper.prototype.handleMouseMove = function (event) {
+    //eslint-disable-next-line
+    console.log("Mouse move event", event);
+    if (!this.props.resizable) return;
+
+    // Calculate the new crop size based on the mouse movement
+    // This is a simplified example, you'll need to add your own logic here
+    var newCropSize = {
+      width: this.state.cropSize.width + event.movementX,
+      height: this.state.cropSize.height + event.movementY,
+    };
+
+    // Check the new crop size against the min and max sizes
+    if (
+      this.props.minCropSize &&
+      (newCropSize.width < this.props.minCropSize.width ||
+        newCropSize.height < this.props.minCropSize.height)
+    )
+      return;
+    if (
+      this.props.maxCropSize &&
+      (newCropSize.width > this.props.maxCropSize.width ||
+        newCropSize.height > this.props.maxCropSize.height)
+    )
+      return;
+
+    // Update the crop size
+    this.setState({ cropSize: newCropSize });
+
+    // Call the onCropResize event handler
+    if (this.props.onCropResize) this.props.onCropResize(newCropSize);
+  };
+
+  //Patch ends
   Cropper.prototype.componentDidMount = function () {
     if (!this.currentDoc || !this.currentWindow) return;
     if (this.containerRef) {
@@ -613,20 +773,21 @@ var Cropper = /** @class */function (_super) {
       }
       this.initResizeObserver();
       // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant
-      if (typeof window.ResizeObserver === 'undefined') {
-        this.currentWindow.addEventListener('resize', this.computeSizes);
+      if (typeof window.ResizeObserver === "undefined") {
+        this.currentWindow.addEventListener("resize", this.computeSizes);
       }
-      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {
-        passive: false
-      });
-      this.containerRef.addEventListener('gesturestart', this.onGestureStart);
+      this.props.zoomWithScroll &&
+        this.containerRef.addEventListener("wheel", this.onWheel, {
+          passive: false,
+        });
+      this.containerRef.addEventListener("gesturestart", this.onGestureStart);
     }
-    this.currentDoc.addEventListener('scroll', this.onScroll);
+    this.currentDoc.addEventListener("scroll", this.onScroll);
     if (!this.props.disableAutomaticStylesInjection) {
-      this.styleRef = this.currentDoc.createElement('style');
-      this.styleRef.setAttribute('type', 'text/css');
+      this.styleRef = this.currentDoc.createElement("style");
+      this.styleRef.setAttribute("type", "text/css");
       if (this.props.nonce) {
-        this.styleRef.setAttribute('nonce', this.props.nonce);
+        this.styleRef.setAttribute("nonce", this.props.nonce);
       }
       this.styleRef.innerHTML = css_248z;
       this.currentDoc.head.appendChild(this.styleRef);
@@ -646,15 +807,22 @@ var Cropper = /** @class */function (_super) {
   Cropper.prototype.componentWillUnmount = function () {
     var _a, _b;
     if (!this.currentDoc || !this.currentWindow) return;
-    if (typeof window.ResizeObserver === 'undefined') {
-      this.currentWindow.removeEventListener('resize', this.computeSizes);
+    if (typeof window.ResizeObserver === "undefined") {
+      this.currentWindow.removeEventListener("resize", this.computeSizes);
     }
-    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
+    (_a = this.resizeObserver) === null || _a === void 0
+      ? void 0
+      : _a.disconnect();
     if (this.containerRef) {
-      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);
+      this.containerRef.removeEventListener(
+        "gesturestart",
+        this.preventZoomSafari
+      );
     }
     if (this.styleRef) {
-      (_b = this.styleRef.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(this.styleRef);
+      (_b = this.styleRef.parentNode) === null || _b === void 0
+        ? void 0
+        : _b.removeChild(this.styleRef);
     }
     this.cleanEvents();
     this.props.zoomWithScroll && this.clearScrollEvent();
@@ -670,24 +838,52 @@ var Cropper = /** @class */function (_super) {
       this.computeSizes();
     } else if (prevProps.zoom !== this.props.zoom) {
       this.recomputeCropPosition();
-    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {
+    } else if (
+      ((_a = prevProps.cropSize) === null || _a === void 0
+        ? void 0
+        : _a.height) !==
+        ((_b = this.props.cropSize) === null || _b === void 0
+          ? void 0
+          : _b.height) ||
+      ((_c = prevProps.cropSize) === null || _c === void 0
+        ? void 0
+        : _c.width) !==
+        ((_d = this.props.cropSize) === null || _d === void 0
+          ? void 0
+          : _d.width)
+    ) {
       this.computeSizes();
-    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {
+    } else if (
+      ((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !==
+        ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) ||
+      ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !==
+        ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)
+    ) {
       this.emitCropAreaChange();
     }
-    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {
-      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {
-        passive: false
-      }) : this.clearScrollEvent();
+    if (
+      prevProps.zoomWithScroll !== this.props.zoomWithScroll &&
+      this.containerRef
+    ) {
+      this.props.zoomWithScroll
+        ? this.containerRef.addEventListener("wheel", this.onWheel, {
+            passive: false,
+          })
+        : this.clearScrollEvent();
     }
     if (prevProps.video !== this.props.video) {
-      (_j = this.videoRef.current) === null || _j === void 0 ? void 0 : _j.load();
+      (_j = this.videoRef.current) === null || _j === void 0
+        ? void 0
+        : _j.load();
     }
     var objectFit = this.getObjectFit();
     if (objectFit !== this.state.mediaObjectFit) {
-      this.setState({
-        mediaObjectFit: objectFit
-      }, this.computeSizes);
+      this.setState(
+        {
+          mediaObjectFit: objectFit,
+        },
+        this.computeSizes
+      );
     }
   };
   Cropper.prototype.getAspect = function () {
@@ -701,17 +897,34 @@ var Cropper = /** @class */function (_super) {
   };
   Cropper.prototype.getObjectFit = function () {
     var _a, _b, _c, _d;
-    if (this.props.objectFit === 'cover') {
+    if (this.props.objectFit === "cover") {
       var mediaRef = this.imageRef.current || this.videoRef.current;
       if (mediaRef && this.containerRef) {
         this.containerRect = this.containerRef.getBoundingClientRect();
-        var containerAspect = this.containerRect.width / this.containerRect.height;
-        var naturalWidth = ((_a = this.imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = this.videoRef.current) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;
-        var naturalHeight = ((_c = this.imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = this.videoRef.current) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;
+        var containerAspect =
+          this.containerRect.width / this.containerRect.height;
+        var naturalWidth =
+          ((_a = this.imageRef.current) === null || _a === void 0
+            ? void 0
+            : _a.naturalWidth) ||
+          ((_b = this.videoRef.current) === null || _b === void 0
+            ? void 0
+            : _b.videoWidth) ||
+          0;
+        var naturalHeight =
+          ((_c = this.imageRef.current) === null || _c === void 0
+            ? void 0
+            : _c.naturalHeight) ||
+          ((_d = this.videoRef.current) === null || _d === void 0
+            ? void 0
+            : _d.videoHeight) ||
+          0;
         var mediaAspect = naturalWidth / naturalHeight;
-        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover';
+        return mediaAspect < containerAspect
+          ? "horizontal-cover"
+          : "vertical-cover";
       }
-      return 'horizontal-cover';
+      return "horizontal-cover";
     }
     return this.props.objectFit;
   };
@@ -729,19 +942,24 @@ var Cropper = /** @class */function (_super) {
     var pointB = Cropper.getTouchPoint(e.touches[1]);
     var center = getCenter(pointA, pointB);
     this.onDrag(center);
-    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);
-    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(function () {
-      var distance = getDistanceBetweenPoints(pointA, pointB);
-      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);
-      _this.setNewZoom(newZoom, center, {
-        shouldUpdatePosition: false
-      });
-      _this.lastPinchDistance = distance;
-      var rotation = getRotationBetweenPoints(pointA, pointB);
-      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);
-      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);
-      _this.lastPinchRotation = rotation;
-    });
+    if (this.rafPinchTimeout)
+      this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout);
+    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(
+      function () {
+        var distance = getDistanceBetweenPoints(pointA, pointB);
+        var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);
+        _this.setNewZoom(newZoom, center, {
+          shouldUpdatePosition: false,
+        });
+        _this.lastPinchDistance = distance;
+        var rotation = getRotationBetweenPoints(pointA, pointB);
+        var newRotation =
+          _this.props.rotation + (rotation - _this.lastPinchRotation);
+        _this.props.onRotationChange &&
+          _this.props.onRotationChange(newRotation);
+        _this.lastPinchRotation = rotation;
+      }
+    );
   };
   Cropper.prototype.render = function () {
     var _this = this;
@@ -766,51 +984,126 @@ var Cropper = /** @class */function (_super) {
       cropAreaClassName = _d.cropAreaClassName,
       mediaClassName = _d.mediaClassName;
     var objectFit = this.state.mediaObjectFit;
-    return React.createElement("div", {
-      onMouseDown: this.onMouseDown,
-      onTouchStart: this.onTouchStart,
-      ref: function ref(el) {
-        return _this.containerRef = el;
+    return React.createElement(
+      "div",
+      {
+        onMouseDown: this.onMouseDown,
+        onTouchStart: this.onTouchStart,
+        ref: function ref(el) {
+          return (_this.containerRef = el);
+        },
+        "data-testid": "container",
+        style: containerStyle,
+        className: classNames("reactEasyCrop_Container", containerClassName),
       },
-      "data-testid": "container",
-      style: containerStyle,
-      className: classNames('reactEasyCrop_Container', containerClassName)
-    }, image ? React.createElement("img", __assign({
-      alt: "",
-      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)
-    }, mediaProps, {
-      src: image,
-      ref: this.imageRef,
-      style: __assign(__assign({}, mediaStyle), {
-        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
-      }),
-      onLoad: this.onMediaLoad
-    })) : video && React.createElement("video", __assign({
-      autoPlay: true,
-      loop: true,
-      muted: true,
-      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', mediaClassName)
-    }, mediaProps, {
-      ref: this.videoRef,
-      onLoadedMetadata: this.onMediaLoad,
-      style: __assign(__assign({}, mediaStyle), {
-        transform: transform || "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rotation, "deg) scale(").concat(zoom, ")")
-      }),
-      controls: false
-    }), (Array.isArray(video) ? video : [{
-      src: video
-    }]).map(function (item) {
-      return React.createElement("source", __assign({
-        key: item.src
-      }, item));
-    })), this.state.cropSize && React.createElement("div", {
-      style: __assign(__assign({}, cropAreaStyle), {
-        width: this.state.cropSize.width,
-        height: this.state.cropSize.height
-      }),
-      "data-testid": "cropper",
-      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)
-    }));
+      image
+        ? React.createElement(
+            "img",
+            __assign(
+              {
+                alt: "",
+                className: classNames(
+                  "reactEasyCrop_Image",
+                  objectFit === "contain" && "reactEasyCrop_Contain",
+                  objectFit === "horizontal-cover" &&
+                    "reactEasyCrop_Cover_Horizontal",
+                  objectFit === "vertical-cover" &&
+                    "reactEasyCrop_Cover_Vertical",
+                  mediaClassName
+                ),
+              },
+              mediaProps,
+              {
+                src: image,
+                ref: this.imageRef,
+                style: __assign(__assign({}, mediaStyle), {
+                  transform:
+                    transform ||
+                    "translate("
+                      .concat(x, "px, ")
+                      .concat(y, "px) rotate(")
+                      .concat(rotation, "deg) scale(")
+                      .concat(zoom, ")"),
+                }),
+                onLoad: this.onMediaLoad,
+              }
+            )
+          )
+        : video &&
+            React.createElement(
+              "video",
+              __assign(
+                {
+                  autoPlay: true,
+                  loop: true,
+                  muted: true,
+                  className: classNames(
+                    "reactEasyCrop_Video",
+                    objectFit === "contain" && "reactEasyCrop_Contain",
+                    objectFit === "horizontal-cover" &&
+                      "reactEasyCrop_Cover_Horizontal",
+                    objectFit === "vertical-cover" &&
+                      "reactEasyCrop_Cover_Vertical",
+                    mediaClassName
+                  ),
+                },
+                mediaProps,
+                {
+                  ref: this.videoRef,
+                  onLoadedMetadata: this.onMediaLoad,
+                  style: __assign(__assign({}, mediaStyle), {
+                    // transform:
+                    //   transform ||
+                    //   "translate("
+                    //     .concat(x, "px, ")
+                    //     .concat(y, "px) rotate(")
+                    //     .concat(rotation, "deg) scale(")
+                    //     .concat(zoom, ")"),
+                  }),
+                  controls: false,
+                }
+              ),
+              (Array.isArray(video)
+                ? video
+                : [
+                    {
+                      src: video,
+                    },
+                  ]
+              ).map(function (item) {
+                return React.createElement(
+                  "source",
+                  __assign(
+                    {
+                      key: item.src,
+                    },
+                    item
+                  )
+                );
+              })
+            ),
+      this.state.cropSize &&
+        React.createElement("div", {
+          style: __assign(__assign({}, cropAreaStyle), {
+            width: this.state.cropSize.width,
+            height: this.state.cropSize.height,
+            // transform:
+            //   transform ||
+            //   "translate("
+            //     .concat(x, "px, ")
+            //     .concat(y, "px) rotate(")
+            //     .concat(rotation, "deg) scale(")
+            //     .concat(zoom, ")"),
+          }),
+          "data-testid": "cropper",
+          className: classNames(
+            "reactEasyCrop_CropArea",
+            cropShape === "round" && "reactEasyCrop_CropAreaRound",
+            showGrid && "reactEasyCrop_CropAreaGrid",
+            cropAreaClassName
+          ),
+        })
+    );
   };
   Cropper.defaultProps = {
     zoom: 1,
@@ -818,26 +1111,26 @@ var Cropper = /** @class */function (_super) {
     aspect: 4 / 3,
     maxZoom: MAX_ZOOM,
     minZoom: MIN_ZOOM,
-    cropShape: 'rect',
-    objectFit: 'contain',
+    cropShape: "rect",
+    objectFit: "contain",
     showGrid: true,
     style: {},
     classes: {},
     mediaProps: {},
     zoomSpeed: 1,
     restrictPosition: true,
-    zoomWithScroll: true
+    zoomWithScroll: true,
   };
   Cropper.getMousePoint = function (e) {
     return {
       x: Number(e.clientX),
-      y: Number(e.clientY)
+      y: Number(e.clientY),
     };
   };
   Cropper.getTouchPoint = function (touch) {
     return {
       x: Number(touch.clientX),
-      y: Number(touch.clientY)
+      y: Number(touch.clientY),
     };
   };
   return Cropper;
